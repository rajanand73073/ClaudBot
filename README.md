# AI Deterministic UI Generator

An AI-powered deterministic UI generation system that converts natural language requests into structured, validated, and explainable UI layouts using a fixed component system.

This project enforces strict architectural boundaries to ensure safety, reproducibility, and deterministic rendering.

---

## ğŸš€ Overview

This system allows users to:

- Describe UI in natural language
- Generate structured UI plans using AI
- Render UI using a fixed component library
- Receive explanations of layout and component decisions
- Iteratively modify existing UIs without full regeneration

The system is designed to prevent hallucinated components, unsafe rendering, and uncontrolled styling.
---

## ğŸ— Architecture

The system follows a multi-step agent pipeline:

```
User Prompt
   â†“
Planner (LLM)
   â†“
Zod Schema Validation
   â†“
Deterministic Renderer
   â†“
Explainer (LLM)
```

### 1ï¸âƒ£ Planner (AI Step 1)
- Converts natural language into structured JSON UI plans.
- Outputs ONLY JSON.
- Uses  system prompt instructions.
- Supports iteration-aware modifications..

### 2ï¸âƒ£ Validation Layer
- Implemented using `zod`.
- Enforces:
  - Allowed component whitelist
  - Strict prop validation
  - No unknown fields (`.strict()`)
- Blocks invalid or hallucinated outputs before rendering.

### 3ï¸âƒ£ Deterministic Renderer
- Uses a component registry 
- Recursively renders UI from validated plan.
- Only pre-registered components can render.

### 4ï¸âƒ£ Explainer (AI Step 2)
- Explains layout decisions and component choices.
- Supports two modes:
  - Fresh generation explanation
  - Iteration-aware change explanation
- When modifying existing plans:
  - Explains what changed
  - Explains what was preserved
  - Explains reasoning behind changes

---

## ğŸ§± Deterministic Component System

The system uses a fixed component library (no dynamic components).

### Allowed Components

- PageLayout
- Section
- Grid
- Navbar
- Sidebar
- Card
- Button
- Input
- Modal
- Table

### Design Rules

- Component implementation and styling never change.
- No external UI libraries.
- No AI-generated CSS.
- No inline styles generated by AI.
- AI may only:
  - Select components
  - Compose layouts
  - Set props
  - Provide content

---

## ğŸ”’ Schema Design

Implemented with:

```ts
z.discriminatedUnion("type", [...])
```

Why?

- Enforces strict component type selection.
- Provides fast and clear validation.
- Prevents prop cross-contamination.
- Blocks unknown fields via `.strict()`.

Recursive schema enables nested layouts safely.

---

## ğŸ” Iteration-Aware Planning

The planner supports incremental edits.

When a previous plan is provided:

- The model modifies the existing structure.
- Preserves components unless explicitly told otherwise.
- Avoids full regeneration.
- Applies only requested changes.

This satisfies the requirement for incremental updates instead of full rewrites.

---

## ğŸ¤– Model Selection

We use Groq-hosted open-source models (e.g., LLaMA 3).

Reasons:
- Fast inference
- Cost-efficient
- Open-source transparency
- OpenAI-compatible API
- Deterministic low-temperature generation

Planner temperature: `0.2`  
Explainer temperature: `0.4`



## ğŸ›¡ Safety Measures

- Strict system prompts
- JSON-only output enforcement
- Safe JSON extraction
- Zod validation before rendering
- Component registry whitelist
- No client-side API key exposure

