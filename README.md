# AI Deterministic UI Generator

An AI-powered deterministic UI generation system that converts natural language requests into structured, validated, and explainable UI layouts using a fixed component system.

This project enforces strict architectural boundaries to ensure safety, reproducibility, and deterministic rendering.

---

## üöÄ Overview

This system allows users to:

- Describe UI in natural language
- Generate structured UI plans using AI
- Render UI using a fixed component library
- Receive explanations of layout and component decisions
- Iteratively modify existing UIs without full regeneration

The system is designed to prevent hallucinated components, unsafe rendering, and uncontrolled styling.
---

##  Architecture

The system follows a multi-step agent pipeline:

```
User Prompt
   ‚Üì
Planner (LLM)
   ‚Üì
Zod Schema Validation
   ‚Üì
Deterministic Renderer
   ‚Üì
Explainer (LLM)
```

### 1Ô∏è‚É£ Planner (AI Step 1)
- Converts natural language into structured JSON UI plans.
- Outputs ONLY JSON.
- Uses  system prompt instructions.
- Supports iteration-aware modifications..

### 2Ô∏è‚É£ Validation Layer
- Implemented using `zod`.
- Enforces:
  - Allowed component whitelist
  - Strict prop validation
  - No unknown fields (`.strict()`)
- Blocks invalid or hallucinated outputs before rendering.

### 3Ô∏è‚É£ Deterministic Renderer
- Uses a component registry 
- Recursively renders UI from validated plan.
- Only pre-registered components can render.

### 4Ô∏è‚É£ Explainer (AI Step 2)
- Explains layout decisions and component choices.
- Supports two modes:
  - Fresh generation explanation
  - Iteration-aware change explanation
- When modifying existing plans:
  - Explains what changed
  - Explains what was preserved
  - Explains reasoning behind changes

---

## üß± Deterministic Component System

The system uses a fixed component library (no dynamic components).

### Allowed Components

- PageLayout
- Section
- Grid
- Navbar
- Sidebar
- Card
- Button
- Input
- Modal
- Table

### Design Rules

- Component implementation and styling never change.
- No external UI libraries.
- No AI-generated CSS.
- No inline styles generated by AI.
- AI may only:
  - Select components
  - Compose layouts
  - Set props
  - Provide content

---

## üîí Schema Design

Implemented with:

```ts
z.discriminatedUnion("type", [...])
```

Why?

- Enforces strict component type selection.
- Provides fast and clear validation.
- Prevents prop cross-contamination.
- Blocks unknown fields via `.strict()`.

Recursive schema enables nested layouts safely.

---

## üîÅ Iteration-Aware Planning

The planner supports incremental edits.

When a previous plan is provided:

- The model modifies the existing structure.
- Preserves components unless explicitly told otherwise.
- Avoids full regeneration.
- Applies only requested changes.

This satisfies the requirement for incremental updates instead of full rewrites.

---

## ü§ñ Model Selection

We use Groq-hosted open-source models (e.g., LLaMA 3,openAI,groq/compound).

Reasons:
- Fast inference
- Cost-efficient
- Open-source transparency
- OpenAI-compatible API
- Deterministic low-temperature generation

Planner temperature: `0.1`  
Explainer temperature: `0.2`



## üõ° Safety Measures

- Strict system prompts
- JSON-only output enforcement
- Safe JSON extraction
- Zod validation before rendering
- Component registry whitelist
- No client-side API key exposure

---

## ‚ö†Ô∏è Validation Error Handling & Deterministic Enforcement

The system intentionally does **not auto-correct or silently mutate invalid outputs**.

Instead, it enforces strict validation transparency.

### Validation Flow

When the Planner generates a UI plan:

1. JSON is parsed.
2. The plan is validated against `UISchema`.
3. If validation fails:
   - The system blocks rendering.
   - Structured validation errors are returned.
   - The Explainer is triggered in **validation-error mode**.

No invalid UI is ever rendered.

---

## Validation Error Explanation Mode

The Explainer supports a dedicated `validation-error` mode.

In this mode:

- It receives:
  - User prompt
  - Raw invalid output
  - Zod validation errors
- It explains:
  - Which property or structure failed
  - Why it violates the deterministic schema
  - How to fix the request
  - Suggest alternative prop names

- It does NOT:
  - Suggest styling hacks
  - Invent unsupported properties

This ensures explanations remain aligned with the deterministic design rules.

Example failure:


Explained as:

- The property is not part of the allowed schema.
- Styling properties are not supported.
- Only predefined props are allowed.

---

## üß† Semantic Constraint Awareness

The system enforces structural correctness at the schema level.

For example:

- `PageLayout` must always exist as the root.
- `Card` does not allow children.
- Components cannot contain arbitrary nested layouts unless defined in schema.

If a user requests:


The planner preserves the required root structure rather than generating invalid output.



## Structural Validation Strategy

Validation occurs in two stages:

### Stage 1 ‚Äî Syntax Validation
- Ensures JSON is valid.
- Ensures schema compliance.

### Stage 2 ‚Äî Deterministic Enforcement
- Blocks unknown fields.
- Prevents unsupported nesting.
- Enforces root structure.

This separation mimics compiler-style validation.

---

## Robust Error Pipeline

The system uses layered error handling:


All async calls are safely wrapped in `try/catch`.
No unhandled promise rejections.
No undefined plan access.

---

## üì¶ Versioning & Iteration Tracking

The system supports:

- Plan version history
- Rollback to previous versions
- Iterative modification instead of regeneration
- Change-aware explanations

Users can navigate between versions safely.

---


## üìä Why This Is Deterministic

The AI does NOT:

- Create new components
- Create new props
- Generate CSS
- Modify component styling
- Inject dynamic behavior

The AI only:

- Selects from allowed components
- Arranges layout structure
- Fills predefined props
- Modifies existing plans incrementally

Rendering remains fully controlled by the fixed component registry.

Key principles:

- Safety over creativity
- Structure over styling
- Validation before rendering
- Transparency over silent correction
- Fixed component grammar
- Controlled recursion
- No runtime mutation

---



## üèÅ Conclusion

This project demonstrates:

- Deterministic AI system design
- Structured schema enforcement
- Multi-agent pipeline architecture
- Validation-first rendering
- Safe UI generation
- Controlled AI usage

It is not a free-form UI generator.

It is a constrained, validated, explainable UI composition engine.
## üåê Live Link
-https://lnkd.in/gnj2utts

---
